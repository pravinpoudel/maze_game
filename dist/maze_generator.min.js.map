{"version":3,"sources":["maze_generator.js"],"names":["w","canvas","ctx","IMG","player","startPosition","endPosition","startIndex","endIndex","removedWallSet","rows","cols","cellSet","path","wall_list","previousTime","Date","first","keyDown","history","getElementById","processInput","elapsedTime","key","canMove","y","push","x","updateScore","a","s","isBreadcumbVisible","isHintVisible","isPathVisible","checkWall","x0","y0","d","x1","y1","h","i","length","playerIndex","score","drawImage","playerImage","destinationImage","cellList","color","centerX","centerY","correctPosition","beginPath","element","arc","Math","PI","randInt","n","drawSprite","random","putBackground","img","fillStyle","width","height","fillRect","floor","timeDiv","innerText","time","scoreBoard","clearRect","showTrack","drawStartAndEnd","show","gameOver","gameOverBoard","highscoreBoard","max","apply","scoreList","findShortestLength","endX","queue","distances","startX","endY","cellIndex","shift","neighbours","comb1","comb2","splice","findShortestPath","currentDistance","hasOwnProperty","document","getContext","src","j","index","found1Index","randIndex","cell1Index","cell2Index","mazeGeneration","found2Index","removedWallString1","removedWallString2","m","update","start","end","drawLine","stroke","arguments","undefined","strokeStyle","lineWidth","spriteLoad","Image","onload","console","log","moveTo","lineTo","init","setup","buttonDiv","value","Number","addEventListener","e","gameLoop","timeStamp","lastRender","render","requestAnimationFrame"],"mappings":"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","file":"maze_generator.min.js","sourcesContent":["let rows = 15;\r\nlet cols = 15;\r\nlet w;\r\nlet cellSet = [];\r\nlet path = [];\r\nlet wall_list = [];\r\nlet canvas, ctx, IMG;\r\nlet removedWallSet = {};\r\nlet player;\r\nlet startPosition;\r\nlet endPosition;\r\nlet startIndex, endIndex;\r\nlet previousTime = new Date();\r\nlet first = true;\r\nlet keyDown = {};\r\nlet history = [];\r\nlet isBreadcumbVisible = true;\r\nlet isHintVisible = false;\r\nlet isPathVisible = false;\r\nlet score = 0;\r\nlet gameOver = false;\r\nlet scoreList = [];\r\nlet playerImage;\r\nlet destinationImage;\r\n\r\nlet buttonDiv = document.getElementById(\"maze_size\");\r\n\r\nbuttonDiv.onclick = (event) => {\r\n  rows = event.srcElement.dataset.value;\r\n  cols = Number(rows);\r\n  rows = Number(rows);\r\n  first = true;\r\n  cellSet = [];\r\n  removedWallSet = {};\r\n  wall_list = [];\r\n  path = [];\r\n  history = [];\r\n  isBreadcumbVisible = true;\r\n  keyDown = {};\r\n  score = 0;\r\n  gameOver = false;\r\n  gameOverBoard.innerText = \"\";\r\n  gameLoop();\r\n};\r\n\r\nwindow.addEventListener(\"keydown\", (e) => {\r\n  let key = e.key;\r\n  if (key == \"w\" || key == \"i\" || key == \"ArrowUp\") {\r\n    key = \"w\";\r\n  }\r\n  if (key == \"a\" || key == \"j\" || key == \"ArrowLeft\") {\r\n    key = \"a\";\r\n  }\r\n  if (key == \"s\" || key == \"k\" || key == \"ArrowDown\") {\r\n    key = \"s\";\r\n  }\r\n  if (key == \"d\" || key == \"l\" || key == \"ArrowRight\") {\r\n    key = \"d\";\r\n  }\r\n  keyDown[key] = true;\r\n});\r\n\r\nfunction processInput(elapsedTime) {\r\n  if (keyDown.w && canMove(\"w\") && player.y > 0) {\r\n    history.push({\r\n      x: player.x,\r\n      y: player.y,\r\n    });\r\n    player.y = player.y - 1;\r\n    updateScore();\r\n  }\r\n  if (keyDown.a && canMove(\"a\") && player.x > 0) {\r\n    history.push({ x: player.x, y: player.y });\r\n    player.x = player.x - 1;\r\n    updateScore();\r\n  }\r\n  if (keyDown.s && canMove(\"s\") && player.y < rows - 1) {\r\n    history.push({\r\n      x: player.x,\r\n      y: player.y,\r\n    });\r\n    player.y = player.y + 1;\r\n    updateScore();\r\n  }\r\n  if (keyDown.d && canMove(\"d\") && player.x < cols - 1) {\r\n    history.push({\r\n      x: player.x,\r\n      y: player.y,\r\n    });\r\n    player.x = player.x + 1;\r\n    updateScore();\r\n  }\r\n  if (keyDown.b) {\r\n    isBreadcumbVisible = !isBreadcumbVisible;\r\n  }\r\n  if (keyDown.h) {\r\n    isHintVisible = !isHintVisible;\r\n  }\r\n  if (keyDown.p) {\r\n    isPathVisible = !isPathVisible;\r\n  }\r\n\r\n  keyDown = {};\r\n}\r\n\r\nfunction canMove(key) {\r\n  let checkWall = {};\r\n  if (key == \"s\") {\r\n    checkWall.x0 = player.x;\r\n    checkWall.y0 = player.y + 1;\r\n    checkWall.x1 = player.x + 1;\r\n    checkWall.y1 = player.y + 1;\r\n  }\r\n\r\n  if (key == \"d\") {\r\n    checkWall.x0 = player.x + 1;\r\n    checkWall.y0 = player.y;\r\n    checkWall.x1 = player.x + 1;\r\n    checkWall.y1 = player.y + 1;\r\n  }\r\n\r\n  if (key == \"w\") {\r\n    checkWall.x0 = player.x;\r\n    checkWall.y0 = player.y;\r\n    checkWall.x1 = player.x + 1;\r\n    checkWall.y1 = player.y;\r\n  }\r\n\r\n  if (key == \"a\") {\r\n    checkWall.x0 = player.x;\r\n    checkWall.y0 = player.y;\r\n    checkWall.x1 = player.x;\r\n    checkWall.y1 = player.y + 1;\r\n  }\r\n\r\n  for (let i = 0; i < wall_list.length; i++) {\r\n    if (\r\n      wall_list[i].x0 == checkWall.x0 &&\r\n      wall_list[i].y0 == checkWall.y0 &&\r\n      wall_list[i].x1 == checkWall.x1 &&\r\n      wall_list[i].y1 == checkWall.y1\r\n    ) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n//[0, n)\r\n\r\nfunction updateScore() {\r\n  let playerIndex = player.x + player.y * cols;\r\n  if (playerIndex != endIndex) {\r\n    let correctPosition =\r\n      path[path.length - 2].x + path[path.length - 2].y * cols;\r\n    if (playerIndex == correctPosition) {\r\n      score += 5;\r\n    } else {\r\n      score -= 2;\r\n    }\r\n  }\r\n}\r\n\r\nfunction drawSprite() {\r\n  ctx.drawImage(playerImage, player.x * w, player.y * w, w, w);\r\n  ctx.drawImage(\r\n    destinationImage,\r\n    cellSet[0][endPosition].x * w,\r\n    cellSet[0][endPosition].y * w,\r\n    w,\r\n    w\r\n  );\r\n\r\n  // ctx.fillStyle = \"rgba(0, 255, 0, 1)\";\r\n  // ctx.fillRect(player.x * w, player.y * w, w, w);\r\n}\r\n\r\nfunction showTrack(cellList, color) {\r\n  let centerX, centerY;\r\n  ctx.fillStyle = color;\r\n  cellList.forEach((element, index) => {\r\n    ctx.beginPath();\r\n    centerX = element.x * w + w / 2;\r\n    centerY = element.y * w + w / 2;\r\n    ctx.arc(centerX, centerY, w / 4, 2 * Math.PI, false);\r\n    ctx.fill();\r\n  });\r\n}\r\n\r\nfunction randInt(n) {\r\n  return Math.floor(Math.random() * n);\r\n}\r\n\r\nfunction putBackground() {\r\n  ctx.drawImage(\r\n    img,\r\n    0,\r\n    0,\r\n    img.width,\r\n    img.height,\r\n    0,\r\n    0,\r\n    canvas.width,\r\n    canvas.height\r\n  );\r\n  ctx.fillStyle = \"#4aa1b0cc\";\r\n  ctx.fillRect(0, 0, canvas.width, canvas.height); // something in the background\r\n}\r\n\r\nfunction render(time) {\r\n  timeDiv.innerText = Math.floor(time / 1000) + \" sec\";\r\n  scoreBoard.innerText = score;\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n  // putBackground();\r\n\r\n  drawStartAndEnd(startPosition, endPosition);\r\n  if (isPathVisible) {\r\n    showTrack(path, \"#939ea0\");\r\n  }\r\n  if (isBreadcumbVisible) {\r\n    showTrack(history, \"#556611\");\r\n  }\r\n  if (isHintVisible) {\r\n    if (path.length > 1) {\r\n      let hint = [path[path.length - 2]];\r\n      showTrack(hint, \"#939ea0\");\r\n    }\r\n  }\r\n  show();\r\n  drawSprite();\r\n  scoreList.push(score);\r\n  if (gameOver) {\r\n    gameOverBoard.innerText = \"You Won !!!!\";\r\n    highscoreBoard.innerText = Math.max(...scoreList);\r\n  }\r\n}\r\n\r\nfunction drawStartAndEnd(startPosition, endPosition) {\r\n  let startX = cellSet[0][startPosition].x;\r\n  let startY = cellSet[0][startPosition].y;\r\n  let endX = cellSet[0][endPosition].x;\r\n  let endY = cellSet[0][endPosition].y;\r\n\r\n  // ctx.drawImage(characterImage, startX.x * w, startY.y * w, w, w);\r\n  // ctx.fillStyle = \"rgba(255, 0, 0, 1)\";\r\n  // ctx.fillRect(endX * w, endY * w, w, w);\r\n}\r\n\r\nfunction findShortestLength(startIndex, endIndex) {\r\n  let queue = [];\r\n  let distances = new Array(rows * cols).fill(-1);\r\n  queue.push(startIndex);\r\n  distances[startIndex] = 0;\r\n  let comb1, comb2;\r\n  while (queue.length > 0) {\r\n    let cellIndex = queue.shift();\r\n    let neighbours = [cellIndex - cols, cellIndex + cols];\r\n    if (cellIndex % cols == 0) {\r\n      neighbours.push(cellIndex + 1);\r\n    } else if (cellIndex % cols == cols - 1) {\r\n      neighbours.push(cellIndex - 1);\r\n    } else {\r\n      neighbours.push(cellIndex + 1);\r\n      neighbours.push(cellIndex - 1);\r\n    }\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      // console.log(\r\n      //   \"index\",\r\n      //   i,\r\n      //   neighbours[i],\r\n      //   comb1,\r\n      //   removedWallSet.hasOwnProperty(comb1),\r\n      //   comb2,\r\n      //   removedWallSet.hasOwnProperty(comb2)\r\n      // );\r\n\r\n      comb1 = neighbours[i] + \"_\" + cellIndex;\r\n      comb2 = cellIndex + \"_\" + neighbours[i];\r\n\r\n      if (!(removedWallSet[comb1] || removedWallSet[comb2])) {\r\n        neighbours.splice(i, 1);\r\n        i--;\r\n      } else if (!(neighbours[i] < rows * cols && neighbours[i] >= 0)) {\r\n        neighbours.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      if (distances[neighbours[i]] == -1) {\r\n        distances[neighbours[i]] = distances[cellIndex] + 1;\r\n        queue.push(neighbours[i]);\r\n        if (neighbours[i] == endIndex) {\r\n          return distances;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction findShortestPath(startIndex, endIndex) {\r\n  let distances = findShortestLength(startIndex, endIndex);\r\n  let cellIndex = endIndex;\r\n  path.push(endIndex);\r\n  let currentDistance = distances[endIndex];\r\n  while (currentDistance > 0) {\r\n    currentDistance = distances[cellIndex];\r\n    let neighbours = [cellIndex - cols, cellIndex + cols];\r\n    if (cellIndex % cols == 0) {\r\n      neighbours.push(cellIndex + 1);\r\n    } else if (cellIndex % cols == cols - 1) {\r\n      neighbours.push(cellIndex - 1);\r\n    } else {\r\n      neighbours.push(cellIndex + 1);\r\n      neighbours.push(cellIndex - 1);\r\n    }\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      comb1 = neighbours[i] + \"_\" + cellIndex;\r\n      comb2 = cellIndex + \"_\" + neighbours[i];\r\n\r\n      if (\r\n        !(\r\n          removedWallSet.hasOwnProperty(comb1) ||\r\n          removedWallSet.hasOwnProperty(comb2)\r\n        )\r\n      ) {\r\n        neighbours.splice(i, 1);\r\n        i--;\r\n      } else if (!(neighbours[i] < rows * cols && neighbours[i] >= 0)) {\r\n        neighbours.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n\r\n    currentDistance--;\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      if (distances[neighbours[i]] == currentDistance) {\r\n        path.push(neighbours[i]);\r\n        break;\r\n      }\r\n    }\r\n    cellIndex = path[path.length - 1];\r\n  }\r\n\r\n  for (let i = 0, length = path.length; i < length; i++) {\r\n    let y = Math.floor(path[i] / cols);\r\n    let x = path[i] % cols;\r\n    path[i] = {\r\n      x,\r\n      y,\r\n    };\r\n  }\r\n}\r\n\r\nfunction setup() {\r\n  canvas = document.getElementById(\"mazecanvas\");\r\n  ctx = canvas.getContext(\"2d\");\r\n  const width = canvas.width;\r\n  const height = canvas.height;\r\n  w = Math.floor(width / rows);\r\n  h = Math.floor(height / cols);\r\n\r\n  img = new Image();\r\n  img.src = \"./background.jpg\";\r\n  for (let i = 0; i < rows; i++) {\r\n    for (let j = 0; j < cols; j++) {\r\n      cellSet.push([\r\n        {\r\n          index: i + j * cols,\r\n          x: i,\r\n          y: j,\r\n        },\r\n      ]);\r\n    }\r\n  }\r\n  for (let i = 0; i < rows; i++) {\r\n    for (let j = 0; j < cols; j++) {\r\n      let x0 = i;\r\n      let y0 = j;\r\n      let x1 = i + 1;\r\n      let y1 = j;\r\n      wall_list.push({\r\n        x0: x0,\r\n        y0: y0,\r\n        x1: x1,\r\n        y1: y1,\r\n      });\r\n\r\n      x1 = i;\r\n      y1 = j + 1;\r\n\r\n      wall_list.push({\r\n        x0: x0,\r\n        y0: y0,\r\n        x1: x1,\r\n        y1: y1,\r\n      });\r\n    }\r\n  }\r\n\r\n  for (let i = 0, j = cols; i < rows; i++) {\r\n    let x0 = i;\r\n    let y0 = j;\r\n    let x1 = i + 1;\r\n    let y1 = j;\r\n\r\n    wall_list.push({\r\n      x0: x0,\r\n      y0: y0,\r\n      x1: x1,\r\n      y1: y1,\r\n    });\r\n  }\r\n\r\n  for (let j = 0, i = rows; j < cols; j++) {\r\n    let x0 = i;\r\n    let y0 = j;\r\n    let x1 = i;\r\n    let y1 = j + 1;\r\n    wall_list.push({\r\n      x0: x0,\r\n      y0: y0,\r\n      x1: x1,\r\n      y1: y1,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mazeGeneration() {\r\n  while (cellSet.length > 1) {\r\n    let n = wall_list.length;\r\n    let found1Index = -1;\r\n    let found2Index = -1;\r\n    let randIndex = randInt(n);\r\n    let cell1Index;\r\n    let cell2Index;\r\n    let removedWallString1;\r\n    let removedWallString2;\r\n\r\n    // console.log(randIndex, n, cellSet)\r\n    if (wall_list[randIndex].y0 == wall_list[randIndex].y1) {\r\n      let x0 = wall_list[randIndex].x0;\r\n      let y0 = wall_list[randIndex].y0;\r\n      for (let i = 0; i < cellSet.length; i++) {\r\n        for (let j = 0; j < cellSet[i].length; j++) {\r\n          if (cellSet[i][j].x == x0 && cellSet[i][j].y == y0) {\r\n            found1Index = i;\r\n            cell1Index = cellSet[i][j].index;\r\n          }\r\n          if (cellSet[i][j].x == x0 && cellSet[i][j].y == y0 - 1) {\r\n            found2Index = i;\r\n            cell2Index = cellSet[i][j].index;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (wall_list[randIndex].x0 == wall_list[randIndex].x1) {\r\n      let x0 = wall_list[randIndex].x0;\r\n      let y0 = wall_list[randIndex].y0;\r\n      for (let i = 0; i < cellSet.length; i++) {\r\n        for (let j = 0; j < cellSet[i].length; j++) {\r\n          if (cellSet[i][j].x == x0 - 1 && cellSet[i][j].y == y0) {\r\n            found1Index = i;\r\n            cell1Index = cellSet[i][j].index;\r\n          }\r\n\r\n          if (cellSet[i][j].x == x0 && cellSet[i][j].y == y0) {\r\n            found2Index = i;\r\n            cell2Index = cellSet[i][j].index;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (found1Index >= 0 && found2Index >= 0) {\r\n      if (found1Index != found2Index) {\r\n        for (let m = 0; m < cellSet[found2Index].length; m++) {\r\n          cellSet[found1Index][cellSet[found1Index].length] = {\r\n            ...cellSet[found2Index][m],\r\n          };\r\n        }\r\n\r\n        let removedWallString1 = cell1Index + \"_\" + cell2Index;\r\n        let removedWallString2 = cell2Index + \"_\" + cell1Index;\r\n\r\n        removedWallSet[removedWallString1] = true;\r\n        removedWallSet[removedWallString2] = true;\r\n\r\n        wall_list.splice(randIndex, 1);\r\n        cellSet.splice(found2Index, 1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction update(time) {\r\n  let startIndex = player.x + player.y * cols;\r\n  path = [];\r\n  if (startIndex == endIndex) {\r\n    gameOver = true;\r\n    return;\r\n  }\r\n  findShortestPath(startIndex, endIndex);\r\n}\r\nfunction show() {\r\n  for (let i = 0; i < wall_list.length; i++) {\r\n    start = [wall_list[i].x0 * w, wall_list[i].y0 * w];\r\n    end = [wall_list[i].x1 * w, wall_list[i].y1 * w];\r\n    drawLine(ctx, start, end, \"#6b789e\", 2);\r\n  }\r\n}\r\n\r\nfunction drawLine(ctx, begin, end, stroke = \"white\", width = 1) {\r\n  if (stroke) {\r\n    ctx.strokeStyle = stroke;\r\n  }\r\n\r\n  if (width) {\r\n    ctx.lineWidth = width;\r\n  }\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(...begin);\r\n  ctx.lineTo(...end);\r\n  ctx.stroke();\r\n}\r\n\r\nfunction spriteLoad() {\r\n  let characterURL = \"./sprites/player.png\";\r\n  let destinationURL = \"./sprites/destination.png\";\r\n  playerImage = new Image();\r\n  playerImage.src = characterURL;\r\n  destinationImage = new Image();\r\n  destinationImage.src = destinationURL;\r\n  playerImage.onload = function () {\r\n    ctx.drawImage(playerImage, player.x * w, player.y * w);\r\n  };\r\n  destinationImage.onload = function () {\r\n    console.log(cellSet[0][endPosition].x * w, cellSet[0][endPosition].y * w);\r\n    ctx.drawImage(\r\n      destinationImage,\r\n      cellSet[0][endPosition].x * w,\r\n      cellSet[0][endPosition].y * w,\r\n      w,\r\n      w\r\n    );\r\n  };\r\n}\r\n\r\nfunction init() {\r\n  setup();\r\n  mazeGeneration();\r\n  do {\r\n    startPosition = randInt(cellSet[0].length);\r\n    endPosition = randInt(cellSet[0].length);\r\n  } while (startPosition == endPosition);\r\n\r\n  spriteLoad();\r\n\r\n  startIndex = cellSet[0][startPosition].index;\r\n  endIndex = cellSet[0][endPosition].index;\r\n\r\n  let trackValue = findShortestLength(startIndex, endIndex);\r\n\r\n  player = {\r\n    x: cellSet[0][startPosition].x,\r\n    y: cellSet[0][startPosition].y,\r\n  };\r\n\r\n  findShortestPath(startIndex, endIndex);\r\n}\r\n\r\nlet timeDiv = document.getElementById(\"elapsedTime\");\r\nlet scoreBoard = document.getElementById(\"scoreBoard\");\r\n\r\nlet highscoreBoard = document.getElementById(\"highscoreBoard\");\r\nlet gameOverBoard = document.getElementById(\"gamOverBoard\");\r\n\r\nfunction gameLoop(timeStamp) {\r\n  if (first) {\r\n    first = false;\r\n    init();\r\n  }\r\n  let elapsedTime = timeStamp - lastRender;\r\n  processInput(elapsedTime);\r\n  update(elapsedTime);\r\n  render(elapsedTime);\r\n  if (!gameOver) {\r\n    requestAnimationFrame(gameLoop);\r\n  }\r\n}\r\nlet lastRender = 0;\r\n"]}