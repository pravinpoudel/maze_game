{"version":3,"sources":["maze_generator.js"],"names":["w","canvas","ctx","isBreadcumbVisible","IMG","rows","cols","cellSet","wall_list","removedWallSet","keyDown","history","processInput","elapsedTime","canMove","player","y","push","x","a","key","checkWall","x1","y1","b","i","length","x0","y0","fillRect","index","beginPath","centerX","element","centerY","Math","PI","randInt","n","floor","putBackground","drawImage","img","width","height","fillStyle","time","showTrack","drawPlayer","drawStartAndEnd","startIndex","endIndex","findShortestPath","startPosition","endPosition","show","console","log","startX","startY","endY","render","timeDiv","innerText","endX","findShortestLength","comb1","comb2","fill","queue","distances","_loop","cellIndex","neighbours","filter","Array","hasOwnProperty","v","_ret","_typeof","currentIndex","path","currentDistance","setup","getElementById","document","getContext","Image","src","j","mazeGeneration","found1Index","found2Index","randIndex","cell1Index","cell2Index","removedWallString1","removedWallString2","m","_objectSpread","splice","start","end","drawLine","arguments","undefined","lineWidth","stroke","apply","_toConsumableArray","begin","strokeStyle","window","addEventListener","e","trackValue","playerY","startingTime","currentTime","previousTime"],"mappings":"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","file":"maze_generator.min.js","sourcesContent":["const rows = 3;\r\nconst cols = 3;\r\nlet w;\r\nlet cellSet = [];\r\nlet wall_list = [];\r\nlet canvas, ctx, isBreadcumbVisible, IMG;\r\nlet removedWallSet = {};\r\n\r\nlet keyDown = {};\r\nlet history = [];\r\nwindow.addEventListener(\"keydown\", (e) => {\r\n  let key = e.key;\r\n  keyDown[key] = true;\r\n});\r\n\r\nfunction processInput(elapsedTime) {\r\n  if (keyDown.w && canMove(\"w\") && player.y > 0) {\r\n    history.push({ x: player.x, y: player.y });\r\n    player.y = player.y - 1;\r\n  }\r\n  if (keyDown.a && canMove(\"a\") && player.x > 0) {\r\n    history.push(player.x * cols + player.y);\r\n    player.x = player.x - 1;\r\n  }\r\n  if (keyDown.s && canMove(\"s\") && player.y < rows - 1) {\r\n    history.push({ x: player.x, y: player.y });\r\n    player.y = player.y + 1;\r\n  }\r\n  if (keyDown.d && canMove(\"d\") && player.x < cols - 1) {\r\n    history.push({ x: player.x, y: player.y });\r\n    player.x = player.x + 1;\r\n  }\r\n  if (keyDown.b) {\r\n    isBreadcumbVisible = !isBreadcumbVisible;\r\n  }\r\n  keyDown = {};\r\n}\r\n\r\nfunction canMove(key) {\r\n  let checkWall = {};\r\n  if (key == \"s\") {\r\n    checkWall.x0 = player.x;\r\n    checkWall.y0 = player.y + 1;\r\n    checkWall.x1 = player.x + 1;\r\n    checkWall.y1 = player.y + 1;\r\n  }\r\n\r\n  if (key == \"d\") {\r\n    checkWall.x0 = player.x + 1;\r\n    checkWall.y0 = player.y;\r\n    checkWall.x1 = player.x + 1;\r\n    checkWall.y1 = player.y + 1;\r\n  }\r\n\r\n  if (key == \"w\") {\r\n    checkWall.x0 = player.x;\r\n    checkWall.y0 = player.y;\r\n    checkWall.x1 = player.x + 1;\r\n    checkWall.y1 = player.y;\r\n  }\r\n\r\n  if (key == \"a\") {\r\n    checkWall.x0 = player.x;\r\n    checkWall.y0 = player.y;\r\n    checkWall.x1 = player.x;\r\n    checkWall.y1 = player.y + 1;\r\n  }\r\n\r\n  for (let i = 0; i < wall_list.length; i++) {\r\n    if (\r\n      wall_list[i].x0 == checkWall.x0 &&\r\n      wall_list[i].y0 == checkWall.y0 &&\r\n      wall_list[i].x1 == checkWall.x1 &&\r\n      wall_list[i].y1 == checkWall.y1\r\n    ) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n//[0, n)\r\n\r\nfunction drawPlayer() {\r\n  ctx.fillStyle = \"rgba(0, 255, 0, 1)\";\r\n  ctx.fillRect(player.x * w, player.y * w, w, w);\r\n}\r\n\r\nfunction showTrack(cellList) {\r\n  let centerX, centerY;\r\n  ctx.fillStyle = \"#df7a12\";\r\n  cellList.forEach((element, index) => {\r\n    ctx.beginPath();\r\n    centerX = element.x * w + w / 2;\r\n    centerY = element.y * w + w / 2;\r\n    ctx.arc(centerX, centerY, w / 3, 2 * Math.PI, false);\r\n    ctx.fill();\r\n  });\r\n}\r\n\r\nfunction randInt(n) {\r\n  return Math.floor(Math.random() * n);\r\n}\r\n\r\nfunction putBackground() {\r\n  ctx.drawImage(\r\n    img,\r\n    0,\r\n    0,\r\n    img.width,\r\n    img.height,\r\n    0,\r\n    0,\r\n    canvas.width,\r\n    canvas.height\r\n  );\r\n  ctx.fillStyle = \"#4aa1b0cc\";\r\n  ctx.fillRect(0, 0, canvas.width, canvas.height); // something in the background\r\n}\r\n\r\nfunction render(time) {\r\n  timeDiv.innerText = Math.floor(time / 1000) + \" sec\";\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n  // putBackground();\r\n  if (isBreadcumbVisible) {\r\n    showTrack(history);\r\n  }\r\n  drawPlayer();\r\n  drawStartAndEnd(startIndex, endIndex);\r\n  findShortestPath(startPosition, endPosition);\r\n  show();\r\n}\r\n\r\nfunction drawStartAndEnd(startPosition, endPosition) {\r\n  let startY = Math.floor(startPosition / cols);\r\n  let startX = startPosition % cols;\r\n\r\n  console.log(startX, startY);\r\n  let endY = Math.floor(endPosition / cols);\r\n  let endX = endPosition % cols;\r\n  // let startX = cellSet[0][startPosition].x;\r\n  // let startY = cellSet[0][startPosition].y;\r\n  // let endX = cellSet[0][endPosition].x;\r\n  // let endY = cellSet[0][endPosition].y;\r\n\r\n  console.log(startPosition, endPosition);\r\n  console.log(startX, startY, endX, endY);\r\n\r\n  ctx.fillStyle = \"rgba(255, 0, 0, 1)\";\r\n  ctx.fillRect(endX * w, endY * w, w, w);\r\n\r\n  ctx.fillStyle = \"rgba(0, 0, 0, 1)\";\r\n  ctx.fillRect(startX * w, startY * w, w, w);\r\n}\r\n\r\nfunction findShortestLength(startIndex, endIndex) {\r\n  let queue = [];\r\n  let distances = new Array(rows * cols).fill(-1);\r\n  console.log(startIndex);\r\n  queue.push(startIndex);\r\n  distances[startIndex] = 0;\r\n  let comb1, comb2;\r\n  while (queue.length > 0) {\r\n    let cellIndex = queue.shift();\r\n    let neighbours = [\r\n      cellIndex - 1,\r\n      cellIndex + 1,\r\n      cellIndex - cols,\r\n      cellIndex + cols,\r\n    ];\r\n\r\n    neighbours.filter((element, index) => {\r\n      comb1 = element + \"_\" + cellIndex;\r\n      comb2 = cellIndex + \"_\" + element;\r\n      if (\r\n        (removedWallSet.hasOwnProperty(comb1) ||\r\n          removedWallSet.hasOwnProperty(comb2)) &&\r\n        element < rows &&\r\n        element < cols &&\r\n        element >= 0\r\n      ) {\r\n        console.log(comb1, comb2);\r\n        return true;\r\n      }\r\n    });\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      if (distances[neighbours[i]] == -1) {\r\n        distances[neighbours[i]] = distances[cellIndex] + 1;\r\n        queue.push(neighbours[i]);\r\n        if (neighbours[i] == endIndex) {\r\n          return distances;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction findShortestPath(startIndex, endIndex) {\r\n  let distances = findShortestLength(startIndex, endIndex);\r\n  console.log(distances);\r\n  let currentIndex = endIndex;\r\n  let path = [endIndex];\r\n  let currentDistance = distances[endIndex];\r\n  console.log(startIndex, endIndex);\r\n  while (currentDistance > 0) {\r\n    currentDistance = distances[currentIndex];\r\n    let neighbours = [\r\n      currentIndex - 1,\r\n      currentIndex + 1,\r\n      currentIndex - cols,\r\n      currentIndex + cols,\r\n    ];\r\n\r\n    neighbours.filter((element, index) => {\r\n      comb1 = element + \"_\" + currentIndex;\r\n      comb2 = currentIndex + \"_\" + element;\r\n      console.log(\r\n        comb1 +\r\n          \"and\" +\r\n          comb2 +\r\n          \"doesnot have wall\" +\r\n          removedWallSet.hasOwnProperty(comb1) ||\r\n          removedWallSet.hasOwnProperty(comb2)\r\n      );\r\n      return (\r\n        (removedWallSet.hasOwnProperty(comb1) ||\r\n          removedWallSet.hasOwnProperty(comb2)) &&\r\n        element < rows &&\r\n        element < cols &&\r\n        element >= 0\r\n      );\r\n    });\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      currentDistance--;\r\n      if (distances[neighbours[i]] == currentDistance) {\r\n        path.push(neighbours[i]);\r\n        break;\r\n      }\r\n    }\r\n    currentIndex = path[path.length - 1];\r\n  }\r\n\r\n  for (let i = 0, length = path.length; i < length; i++) {\r\n    let y = Math.floor(path[i] / cols);\r\n    let x = path[i] % cols;\r\n    path[i] = { x, y };\r\n  }\r\n\r\n  showTrack(path);\r\n}\r\n\r\nfunction setup() {\r\n  canvas = document.getElementById(\"mazecanvas\");\r\n  ctx = canvas.getContext(\"2d\");\r\n  const width = canvas.width;\r\n  const height = canvas.height;\r\n  w = Math.floor(width / rows);\r\n  h = Math.floor(height / cols);\r\n\r\n  img = new Image();\r\n  img.src = \"./background.jpg\";\r\n  for (let i = 0; i < rows; i++) {\r\n    for (let j = 0; j < cols; j++) {\r\n      cellSet.push([{ index: i * cols + j, x: i, y: j }]);\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < rows; i++) {\r\n    for (let j = 0; j < cols; j++) {\r\n      let x0 = i;\r\n      let y0 = j;\r\n      let x1 = i + 1;\r\n      let y1 = j;\r\n      wall_list.push({\r\n        x0: x0,\r\n        y0: y0,\r\n        x1: x1,\r\n        y1: y1,\r\n      });\r\n\r\n      x1 = i;\r\n      y1 = j + 1;\r\n\r\n      wall_list.push({\r\n        x0: x0,\r\n        y0: y0,\r\n        x1: x1,\r\n        y1: y1,\r\n      });\r\n    }\r\n  }\r\n\r\n  for (let i = 0, j = cols; i < rows; i++) {\r\n    let x0 = i;\r\n    let y0 = j;\r\n    let x1 = i + 1;\r\n    let y1 = j;\r\n\r\n    wall_list.push({\r\n      x0: x0,\r\n      y0: y0,\r\n      x1: x1,\r\n      y1: y1,\r\n    });\r\n  }\r\n\r\n  for (let j = 0, i = rows; j < cols; j++) {\r\n    let x0 = i;\r\n    let y0 = j;\r\n    let x1 = i;\r\n    let y1 = j + 1;\r\n    wall_list.push({\r\n      x0: x0,\r\n      y0: y0,\r\n      x1: x1,\r\n      y1: y1,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mazeGeneration() {\r\n  while (cellSet.length > 1) {\r\n    let n = wall_list.length;\r\n    let found1Index = -1;\r\n    let found2Index = -1;\r\n    let randIndex = randInt(n);\r\n    let cell1Index;\r\n    let cell2Index;\r\n    let removedWallString1;\r\n    let removedWallString2;\r\n\r\n    // console.log(randIndex, n, cellSet)\r\n    if (wall_list[randIndex].y0 == wall_list[randIndex].y1) {\r\n      let x0 = wall_list[randIndex].x0;\r\n      let y0 = wall_list[randIndex].y0;\r\n      for (let i = 0; i < cellSet.length; i++) {\r\n        for (let j = 0; j < cellSet[i].length; j++) {\r\n          if (cellSet[i][j].x == x0 && cellSet[i][j].y == y0) {\r\n            found1Index = i;\r\n            cell1Index = cellSet[i][j].index;\r\n          }\r\n          if (cellSet[i][j].x == x0 && cellSet[i][j].y == y0 - 1) {\r\n            found2Index = i;\r\n            cell2Index = cellSet[i][j].index;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (wall_list[randIndex].x0 == wall_list[randIndex].x1) {\r\n      let x0 = wall_list[randIndex].x0;\r\n      let y0 = wall_list[randIndex].y0;\r\n      for (let i = 0; i < cellSet.length; i++) {\r\n        for (let j = 0; j < cellSet[i].length; j++) {\r\n          if (cellSet[i][j].x == x0 - 1 && cellSet[i][j].y == y0) {\r\n            found1Index = i;\r\n            cell1Index = cellSet[i][j].index;\r\n          }\r\n\r\n          if (cellSet[i][j].x == x0 && cellSet[i][j].y == y0) {\r\n            found2Index = i;\r\n            cell1Index = cellSet[i][j].index;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (found1Index >= 0 && found2Index >= 0) {\r\n      if (found1Index != found2Index) {\r\n        for (let m = 0; m < cellSet[found2Index].length; m++) {\r\n          cellSet[found1Index][cellSet[found1Index].length] = {\r\n            ...cellSet[found2Index][m],\r\n          };\r\n        }\r\n\r\n        let removedWallString1 = cell1Index + \"_\" + cell2Index;\r\n        let removedWallString2 = cell2Index + \"_\" + cell1Index;\r\n\r\n        removedWallSet[removedWallString1] = true;\r\n        removedWallSet[removedWallString2] = true;\r\n\r\n        wall_list.splice(randIndex, 1);\r\n        cellSet.splice(found2Index, 1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction show() {\r\n  for (let i = 0; i < wall_list.length; i++) {\r\n    start = [wall_list[i].x0 * w, wall_list[i].y0 * w];\r\n    end = [wall_list[i].x1 * w, wall_list[i].y1 * w];\r\n    drawLine(ctx, start, end, \"white\", 6);\r\n  }\r\n}\r\n\r\nfunction drawLine(ctx, begin, end, stroke = \"white\", width = 1) {\r\n  if (stroke) {\r\n    ctx.strokeStyle = stroke;\r\n  }\r\n\r\n  if (width) {\r\n    ctx.lineWidth = width;\r\n  }\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(...begin);\r\n  ctx.lineTo(...end);\r\n  ctx.stroke();\r\n}\r\n\r\nsetup();\r\nmazeGeneration();\r\nshow();\r\n\r\nlet startPosition;\r\nlet endPosition;\r\n\r\ndo {\r\n  startPosition = randInt(cellSet[0].length);\r\n  endPosition = randInt(cellSet[0].length);\r\n} while (startPosition == endPosition);\r\n\r\nconsole.log(startPosition, endPosition);\r\nlet startIndex = cellSet[0][startPosition].index;\r\nlet endIndex = cellSet[0][endPosition].index;\r\n\r\nconsole.log(\"starting cell is \" + startPosition + \"end cell is \" + endIndex);\r\nlet trackValue = findShortestLength(startIndex, endIndex);\r\n\r\nconsole.log(startIndex);\r\nlet playerY = Math.floor(startIndex / cols);\r\nlet playerX = startIndex % cols;\r\n\r\nconst player = {\r\n  x: playerX,\r\n  y: playerY,\r\n};\r\n\r\nconsole.log(player);\r\nctx.fillStyle = \"rgba(0, 255, 0, 1)\";\r\nctx.fillRect(player.x * w, player.y * w, w, w);\r\n\r\nlet startingTime;\r\nlet previousTime;\r\nlet timeDiv = document.getElementById(\"elapsedTime\");\r\nfunction gameLoop(currentTime) {\r\n  if (!startingTime) {\r\n    startingTime = currentTime;\r\n  }\r\n  let elapsedTime = currentTime - startingTime;\r\n  // update(elapsedTime);\r\n  processInput(elapsedTime);\r\n  render(elapsedTime);\r\n  // requestAnimationFrame(gameLoop);\r\n}\r\n\r\ngameLoop();\r\n"]}